# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['Module']

# Cell
#export
import torch
import torch.nn as nn

# Cell
class Module(nn.Module):
    def __init__(self, **kwargs):
        super(Module, self).__init__(**kwargs)

    def train_step(self, batch):
        self.train()

        inputs, labels = batch
        self.optimizer.zero_grad()
        outputs = self(inputs)
        loss = self.loss_fn(outputs, labels)
        loss.backward()
        self.optimizer.step()
        return loss.item()

    def validation_step(self, batch):
        self.eval()

        inputs, labels = batch
        with torch.no_grad():
            outputs = self(inputs)
            loss = self.loss_fn(outputs, labels)
        return loss.item()

    def fit(self, trainloader, epochs, validationloader=None):
        for epoch in range(epochs):
            for batch_idx, batch in enumerate(trainloader):
                batch_loss = self.train_step(batch)
            if validationloader is not None:
                for batch_idx, batch in enumerate(validationloader):
                    batch_loss = self.validation_step(batch)

    def compile(self, loss=None, optimizer=None, metrics=None):
        self.loss_fn = loss
        self.optimizer = optimizer
        self.metrics = metrics

    def evaluate(self, dataloader):
        results = [self.validation_step(batch) for batch in dataloader]
        return sum(results)/len(results)